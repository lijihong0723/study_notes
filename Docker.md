# Docker容器的数据卷

第二、Docker数据卷本质上是存在于Docker宿主机的文件系统中。

第三、Docker数据卷可以是目录，也可以是文件。

第四、Docker可以利用

第五、同一个目录的文件可以支持多个容器的访问。



## 数据卷（Data Volume）的特点

- 数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。

- 数据卷可以在容器之间共享和重用。

- 容器对数据卷的修改是即时进行的，所有的修改都会直接地体现在数据卷中。

- 数据卷的变化不会影响镜像的更新。因为刚才讲到，数据卷是独立于联合文件系统，而镜像本身则基于联合文件系统，所以镜像和数据卷之间不会存在相互影响的情况。

- 数据卷会一直存在，即使挂载数据卷的容器已经被删除。也是因为数据卷本质上是宿主机上的一个目录。数据持久化，它的生存周期与容器完全隔离。

  

## 数据卷的使用

### 为容器添加数据卷（创建包含数据卷的容器）

```shell
sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash
```

我们可以使用docker run命令的-v选项来指定在本机文件系统中的目录和在容器中映射的目录名。如果本机中不存在container_data文件夹，那么docker run命令会在本地自动创建这样一个目录。运行后，可以在容器中看到/data的文件目录。

现在在/data目录中创建一个文件，并使用echo命令输出一个字符串，然后使用exit退出容器。

```shell
touch /data/c1
echo "I'm in container" > /data/c1
exit
```

然后在宿主机上运行ls命令，

```shell
ls -l
```

可以看到宿主机下，有一个container_data的文件夹，然后查看文件夹中的内容，可以看到容器中创建的c1文件已经存在了。可以使用编辑器打开文件，可以看到输出的字符也已经存在了。使用dockerinspect查看一下镜像。可以看到输出中包含了类似

```json
"Volume": {
    ""
}
```

也就是说，可以使用docker inspect命令来查看一个容器是否挂载了数据卷。

### 为数据卷添加访问权限

```shell
$ sudo docker run -v ~/datavolume:/data:ro -it ubuntu /bin/bash
```

添加权限的方式就是在指定映射目录后，再指定访问权限。

实例：

使用docker run 命令再启动一个新的容器，数据卷的设置与刚才完全一样，但是在之后添加一个只读的文件权限限制。

```shell
$ sudo run -it -v ~/datavolume:data:rp --name dvt1 ubuntu /bin/bash
```

可以看到，创建文件时会提示错误。因为挂载数据卷时，使用了只读的选项，因此我们就无法在这个容器中创建文件。

可以执行ls命令，运行后可以看到在数据卷中存在c1文件，并且可以打开这个文件。使用docker inspect命令可以看到VolumesRW中数据卷的写权限为false，之前创建的容器的数据卷写权限为true。因此，我们也可以通过docker inspect命令来查看容器中数据卷的写权限。

除了使用docker run命令。我们也可以使用Dockerfile构建一个包含数据卷的镜像，并使用这个镜像来创建包含数据卷的容器。Dockerfile中的指令如下：

```shell
VOLUME["/data"]
```

与docker run命令中创建数据卷不同，在dockerfile中创建的数据卷时不能够映射到本地文件系统中的。并且运行同样命令所创建的数据卷也是不一样的。

可以看到，新创建的容器中，已经挂载了新创建的两个目录。这时，我们还是使用docker inspect命令来查看我们刚刚创建的容器。我们看到在volumes里包含了两个数据卷，而这两个数据卷映射的本地数据卷也是docker自动创建的。如果这时，我们以同样的镜像再创建一个容器，我们再次使用inspact命令查看新容器的数据卷映射的地址。，可以看到和前面的是不一样的，也就是说在容器启动是，我们在镜像中指定的数据卷都会进行一次完整的初始化。那么使用镜像来创建的容器的数据卷就没办法实现共享。那么当我们不能访问到本地目录时，我们怎样在容器之间共享数据呢？这就涉及到我们下节课将要讲述的内容：数据卷容器，我们也可以通过数据卷容器来实现容器之间的数据共享。

## Docker的数据卷容器

上节课中，我们曾经提到过docker挂载数据卷的容器来实现数据的共享。那么，什么是数据卷容器呢？一个明明的容器挂载了数据卷，其他的容器通过挂载这个容器实现数据共享，挂载数据卷的容器就叫做数据卷容器。

通过下图可以看到：数据卷容器和……的不同。 数据卷容器挂载了一个本地目录，其它容器通过连接这个数据卷容器来实现数据卷的共享。那么数据卷容器是怎样被使用的呢？

### 使用数据卷容器

挂载数据卷容器的方法：

```shell
$ docker run --volumes-from [CONTAINER NAME]
```

我们使用docker run命令的volumes-from选项来指定新建容器所连接的数据卷容器。而volume-from选项的值是已经挂载了数据卷的容器的名字。

在上节课中，我们已经创建了

首先使用镜像来创建一个名为dvt4的容器，这里我们看到了容器中包含了我们在镜像中指定的两个数据卷。使用touch命令在其中一个数据卷中写入一个文件。

```shell
touch /datavolume1/dvt4_1
```

下面，我们来创建一个容器来挂载刚刚我们建立的包含了数据卷的容器。新容器我们给它起名叫dvt5。

```shell
docker run -it --name dvt5 --volumes-from dvt4 ubuntu /bin/bash
```

然后我们使用volumes-from选项来指定我们要挂载的容器名字。这里，我们只需要使用ubuntu系统就可以了。通过ls命令可以看到dvt5已经挂载了在dvt4中所挂载的数据卷。再查看我们

并且我们也能够访问到刚刚我们创建好的两个文件。也就是说，使用数据卷容器，可以很容易地在不同容器间共享数据。同时，我们不需要确切知道容器连接的docker宿主机目录，这一点在多租户的使用环境下非常重要。因为在这种情况下，我们并不像暴露实际的服务器目录。

```shell
docker inspect --format="{{.volumes}}" dvt5
docker inspect --format="{{.volumes}}" dvt6
```

可以看到使用数据卷容器来挂载一个数据卷时，在inspect信息中，并不会直接反映数据卷容器的信息，而是直接返回了数据卷容器所挂载的数据卷目录。也正因为这样，我们可以实现数据的共享。

现在，我们来做一个有意思的事。我们删除用来提供数据共享的数据卷容器。接着，我们再来访问dvt5.

```shell
$ docker rm dvt4
$ docker restart dvt5
$ docker attach dvt5
```

可以看到目录名还是存在。我们使用touch命令来创建一个新文件

```shell
$ touch datavolume1/dvt5_2
$ ls datavolume1
```

可以看到，即使我们删除了数据卷容器，挂载了数据卷容器的容器仍然可以访问数据卷容器所挂载的目录。也就是说，通过数据卷容器来挂载数据卷，容器在这中间的作用仅仅是数据卷配置信息的传递。

下面再来做一个实验，首先创建一个dvt8的数据卷容器，接着创建一个名为dvt9的容器，来挂载：

```shell
$ docker run --name dvt8 dormancypress/dvt
$ docker run --name dvt9 -it --volumes-from dvt8 ubuntu /bin/bash
$ touch /datavolume1/dvt9_1
$ docker rm -v dvt8
```

现在删除dvt8容器，同时再rm命令中加入了-v(在删除时，同时删除其挂载的数据卷)选项。下面，再访问dvt9，发现依然可以访问dvt8挂载的数据卷。这是因为在docker中，如果一个数据卷还在被容器使用，那么它就会一直存在。而且，也验证了我们之前的说法，使用数据卷容器来挂载数据，数据卷容器所起到的作用仅仅是将数据卷挂载的配置传递到挂载了数据卷容器的新容器中。这节课就到这里，在这节课中我们学习了什么是数据卷容器，以及它是怎样被使用的。下一节课中，我们将继续学习使用数据卷和数据卷容器，在docker中进行数据的管理。

## Docker数据卷的备份和还原

那么就不可避免对这些数据进行备份以及还原，或者是迁移操作。

### 数据备份方法

如何利用数据卷的操作进行备份呢？这里给出了docker的命令。

```shell
$ docker run --volumes-from [CONTAINER NAME] -v $(pwd):/backup ubuntu
$ tar cvf /backup/backup.tar [container data volume]
```

在这个命令中实际上包含了两种挂载方式：（1）使用volumes-from选项，挂载了我们需要备份的容器名；-v参数制定了要保存的路径，



## Kubernetes概述

Docker解决了打包和隔离的问题，但在集群中使用docker，我们还要解决更多的问题，比如调度问题（容器在哪运行）、生命周期与健康状况问题（如何确保容器在无措的情况下运行）、服务发现的问题（容器在哪、如何通信）、监控问题（容器是否运行正常）、认证问题（谁能访问容器）、容器聚合的问题（如何将多个关联的容器聚合成一个工程）。

那么在集群当中运行docker容器需要考虑这么多问题，但docker并没有给出解决方案。Kubernetes的产生就是为了解决这些问题的。

Kubernetes是在集群中，开源系统。它使容器化微服务为基础的应用变得简单。它是一个非常轻量级、非常简单的系统；它可以在公有云、私有云以及混合云中部署；在Kubernetes的设计中，他考虑了以下几个问题：首先，它的所有功能都是以模块化（modular）的形式实现的，其次，它支持可插拔化（pluggable），第三方应用添加到kubernetes中，可挂载的（hookable），可以接受kubernetes产生的事件并给出相应的处理，可组合（composable）可以任意选择其中的功能，组合成一个完整的系统。同时它提供了容器的自动恢复、自动重启、自动复制。



从这张图中，我们可以看到，Kubernetes由两个角色。首先是一个master的角色；其次是一个node。master管理节点。